oopsla:
  authors:
    - who: Arjen Rouvoet
      affiliation: Delft University of Technology
      site: https://ajrouvoet.github.io/
    - who: Hendrik van Antwerpen
      affiliation: Delft Universtiy of Technology
      site: https://hendrik.van-antwerpen.net/
    - who: Casper Bach Poulsen
      affiliation: Delft University of Technology
      site: http://casperbp.net/
    - who: Robbert Krebbers
      affiliation: Radboud University and Delft University of Technology
      site: https://robbertkrebbers.nl/
    - who: Eelco Visser
      affiliation: Delft University of Technology
      site: http://eelcovisser.org/

  title: Knowing when to ask
  subtitle: >
      Sound scheduling name resolution queries in type checkers derived from
      declarative specifications
  publication:

  abstract: >
    There is a large gap between the specification of type systems and the
    implementation of their type checkers, which impedes reasoning about the
    soundness of the type checker with respect to the specification. A vision to
    close this gap involves automatically obtaining type checkers from declarative
    programming language specifications. This moves the burden of proving
    correctness from a case-by-case basis for concrete languages, to a single
    correctness proof for the specification language.
    This vision is obstructed by an aspect common to all programming languages: name
    resolution. Naming and scoping are pervasive and complex aspects of the static
    semantics of programming languages. Implementations of type checkers for
    languages with name binding features such as modules, imports, classes, and
    inheritance interleave collection of binding information (i.e., declarations,
    scoping structure, and imports) and querying that information. This requires
    scheduling those two aspects in such a way that query answers are stable—i.e.,
    they are computed only after all relevant binding structure has been
    collected. Type checkers for concrete languages accomplish stability using
    language-specific knowledge about the type system.

    In this paper we give a language independent characterization of necessary and
    sufficient conditions to guarantee stability of name and type queries during
    type checking in terms of critical edges in an incomplete scope graph. We use
    critical edges to give a formal small-step operational semantics to a
    declarative specification language for type systems, delaying queries that may
    depend on missing information. This yields type checkers for the specified
    languages that are safe-by-construction—i.e., they safely schedule queries and
    only accept programs that are name- and type-correct according to the
    declarative language specification. We implement this approach, and evaluate it
    against specifications of a small module and record language, as well as subsets
    of Java and Scala.

  links:
      pdf: https://zenodo.org/record/4091445
      Artifact: https://zenodo.org/record/4068065
      Talk: https://www.youtube.com/watch?v=n9RmjfKnlp8
      site: /#/papers/knowing-when-to-ask

cpp:
  authors:

    - who: Arjen Rouvoet
      affiliation: Delft University of Technology
    - who: Casper Bach Poulsen
      affiliation: Delft University of Technology
      site: http://casperbp.net/
    - who: Robbert Krebbers
      affiliation: Delft University of Technology
      site: https://robbertkrebbers.nl/
    - who: Eelco Visser
      affiliation: Delft University of Technology
      site: http://eelcovisser.org/

  publication:

  title: Intrinsically-Typed Definitional Interpreters for Linear, Session-Typed Languages

  abstract: >
    An intrinsically-typed definitional interpreter is a concise
    specification of dynamic semantics, that is executable and type safe
    by construction.  Unfortunately, scaling intrinsically-typed
    definitional interpreters to more complicated object languages often
    results in definitions that are cluttered with manual proof work.  For
    linearly-typed languages (including session-typed languages) one has
    to prove that the interpreter, as well as all the operations on
    semantic components, treat values linearly. We present new methods
    and tools that make it possible to implement intrinsically-typed
    definitional interpreters for linearly-typed languages in a way that
    hides the majority of the manual proof work. Inspired by separation
    logic, we develop reusable and composable abstractions for programming
    with linear operations using dependent types. Using these
    abstractions, we define interpreters for linear lambda calculi with
    strong references, concurrency, and session-typed communication in
    Agda.

  links:
    pdf: https://dl.acm.org/doi/pdf/10.1145/3372885.3373818
    code: https://github.com/metaborg/linear.agda
    LFCS talk: https://www.youtube.com/watch?v=9WmOmpyz_qo
    CPP talk: https://www.youtube.com/watch?v=xzGzwiYQJWE